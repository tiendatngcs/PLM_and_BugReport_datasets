import logging
import random

from data.bug_dataset import BugDataset


class BugDataExtractor(object):
    """
    It converts the raw data to data that the neural network can use to train.
    """

    def __init__(self, bugReportDataset, dataHandlers):
        self.dataHandlers = dataHandlers
        self.bugreportDataset = bugReportDataset

        # Store the representation of each bug
        self.cache = {}

    def extract(self, bugId):
        # Search in the cache
        c = self.cache.get(bugId)

        if c:
            return c

        # Extract the information and save in the cache
        bug = self.bugreportDataset.getBug(bugId)

        ftrs = []

        for extractor in self.dataHandlers:
            ftrs.append(extractor.extract(bug))

        self.cache[bugId] = ftrs

        return ftrs


class TripletBugDatasetGenerator(object):

    def __init__(self, tripletFile, bugDataExtractor, trainingDatasetPath, bugDatabase):
        # Store the feature generated by bug
        self.inputBug = []
        self.inputDuplicateBug = []
        self.cache = {}
        self.trainingDataset = BugDataset(trainingDatasetPath)
        self.pairs = []

        self.bugIds = [bugDatabase.bugList[idx]['bug_id'] for idx in range(self.trainingDataset.end)]
        self.masterIdByBugId = bugDatabase.getMasterIdByBugId(self.bugIds)
        self.bugDataExtractor = bugDataExtractor

        f = open(tripletFile, 'r')

        self.logger = logging.getLogger(__name__)

        for l in f:
            bugId, duplicateBugId, nonDuplicateBugId = l.strip().split(',')

            ftrsBug = bugDataExtractor.extract(bugId)
            ftrsDuplicateBug = bugDataExtractor.extract(duplicateBugId)

            self.inputBug.append(ftrsBug)
            self.inputDuplicateBug.append(ftrsDuplicateBug)
            self.pairs.append((bugId, duplicateBugId))

    def __len__(self):
        return len(self.pairs)

    def drawNegative(self, bugId):
        negBugId = random.choice(self.bugIds)
        masterId = self.masterIdByBugId[bugId]

        while self.masterIdByBugId[negBugId] == masterId:
            negBugId = random.choice(self.bugIds)

        bug = self.bugDataExtractor.extract(negBugId)

        return bug

    def __getitem__(self, idx):
        """
        Return a tuple (b1, b2, t) where b1 is a tuple with the data from each information type of bug 1,
        b2 is a tuple with the data from each information type of bug 2 and t is the target.

        We consider that b1 and b2 contains all the possible information types in the same order.
        From example the second element of b1 and b2 is always the data from the summary.
        If we are not using this information, so second element of b1 and b2 will be equal to None.
        :param idx:
        :return:
        """
        bugId = self.pairs[idx][0]

        return self.inputBug[idx] + self.inputDuplicateBug[idx] + self.drawNegative(bugId)


class LazyPairBugDatasetReader(object):

    def __init__(self, pairFile, ignoreNegative=False, randomInvertPair=False):
        """
        :param pairFile:
        :param lexicon:
        :param database:
        :type database data.bug_report_database.BugReportDatabase
        """
        f = open(pairFile, 'r')

        self.logger = logging.getLogger(__name__)
        self.pairs = []
        self.randomInvertPair = randomInvertPair
        self.ignoreNegative = ignoreNegative

        for l in f:
            anchorId, OtherBugId, label = l.strip().split(',')
            label = max(0., float(label))

            if label > 0 or not self.ignoreNegative:
                self.pairs.append((anchorId, OtherBugId, label))

        self.logger.info("Using Pairs - Total={}, Randomly Invert Pair={}".format(len(self.pairs), randomInvertPair))

    def __len__(self):
        return len(self.pairs)

    def __getitem__(self, idx):
        output = self.pairs[idx]

        if self.randomInvertPair and random.random() < 0.5:
            return [output[1], output[0], output[2]]

        return output


class PairBugDatasetReader(object):
    """
    Read dataset that contains a pair of bugs and a label in each line.
    """

    def __init__(self, pairFile, preprocessor, negPairGenerator=None, randomInvertPair=False):
        """
        :param pairFile:
        :param lexicon:
        :param database:
        :parama random_query:
        :type database data.bug_report_database.BugReportDatabase
        """
        f = open(pairFile, 'r')

        self.logger = logging.getLogger(__name__)
        self.inputBug = []
        self.pairWithIds = []
        self.positivePairs = []
        self.negativePairs = []
        self.preprocessor = preprocessor
        self.negPairGenerator = negPairGenerator
        self.randomInvertPair = randomInvertPair

        for l in f:
            anchorId, OtherBugId, label = l.strip().split(',')

            anchorBug = preprocessor.extract(anchorId)
            ftrsOtherBug = preprocessor.extract(OtherBugId)

            label = max(0., float(label))

            pair = [anchorBug, ftrsOtherBug, label]

            if label > 0:
                pairList = self.positivePairs
            else:
                pairList = self.negativePairs

            self.inputBug.append(pair)
            pairList.append(pair)

            self.pairWithIds.append([anchorId, OtherBugId, label])

        self.logger.info(
            "Using Pairs - Total={}, Num of Negative Pairs={}, Num of Positive Pairs={}, Randomly Invert Pair={}".format(
                len(self.inputBug), len(self.positivePairs), len(self.negativePairs), randomInvertPair))

    def __len__(self):
        return len(self.inputBug)

    def __getitem__(self, idx):
        output = self.inputBug[idx]

        if self.randomInvertPair and random.random() < 0.5:
            return [output[1], output[0], output[2]]

        return output

    def sampleNewNegExamples(self, model, loss):
        if self.negPairGenerator is None:
            return

        positivePairs, negativePairs = self.negPairGenerator.generatePairs(model, loss, self.positivePairs,
                                                                           self.pairWithIds)
        self.inputBug = positivePairs + negativePairs

        return self.inputBug


class TripletBugDatasetReader(object):
    """
    Read dataset that contains a pair of bugs and a label in each line.
    """

    def __init__(self, tripletFile, preprocessor, negPairGenerator=None, randomInvertPair=False):
        """
        :param tripletFile:
        :param lexicon:
        :param database:
        :type database data.bug_report_database.BugReportDatabase
        """
        f = open(tripletFile, 'r')

        self.logger = logging.getLogger(__name__)
        self.inputBug = []
        self.tripletIds = []
        self.positivePairs = []
        self.negativePairs = []
        self.preprocessor = preprocessor
        self.negPairGenerator = negPairGenerator
        self.randomInvertPair = randomInvertPair
        maxSentenceSize = 300
        # self.masterIdByBugId = masterIdByBugId

        self.logger.info("Using Triplets")

        for l in f:
            anchorId, posId, negId = l.strip().split(',')

            anchorBug = preprocessor.extract(anchorId)
            posBug = preprocessor.extract(posId)
            negBug = preprocessor.extract(negId)

            triplet = [anchorBug, posBug, negBug]

            self.positivePairs.append(((anchorId, anchorBug), (posId, posBug)))

            self.inputBug.append(triplet)
            self.tripletIds.append([anchorId, posId, negId])

    def __len__(self):
        return len(self.inputBug)

    def __getitem__(self, idx):
        """
        Return a tuple (b1, b2, t) where b1 is a tuple with the data from each information type of bug 1,
        b2 is a tuple with the data from each information type of bug 2 and t is the target.

        We consider that b1 and b2 contains all the possible information types in the same order.
        From example the second element of b1 and b2 is always the data from the summary.
        If we are not using this information, so second element of b1 and b2 will be equal to None.
        :param idx:
        :return:
        """
        output = self.inputBug[idx]

        if self.randomInvertPair and random.random() < 0.5:
            return [output[1], output[0], output[2]]

        return output

    def sampleNewNegExamples(self, model, loss):
        if self.negPairGenerator is None:
            return

        self.inputBug = self.negPairGenerator.generateTriplets(model, loss, self.positivePairs)

        return self.inputBug
